<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <title>Mounting Components</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>

<div id="react-container"></div>
    
<script type="text/babel">

    class Box extends React.Component{
        
        componentWillMount() {
            alert("Component is about to mount.")
        }

        /* 
        There is a common misconception that fetching in componentWillMount lets you avoid the first empty rendering state. In practice this was never true because React has always executed render immediately after componentWillMount. If the data is not available by the time componentWillMount fires, the first render will still show a loading state regardless of where you initiate the fetch. This is why moving the fetch to componentDidMount has no perceptible effect in the vast majority of cases.
        */

        componentDidMount() {
            alert("Component has mounted.")
        }

        render() {
            return(
                <div id="mybox"></div>
            )
        }
    }

    ReactDOM.render( <Box/>, document.getElementById( 'react-container' ));

var getRidOfBox = document.getElementById("mybox");
getRidOfBox.onClick = function() {
    ReactDOM.unmountComponentAtNode(document.getElementById( 'react-container' ));
    alert("Component has now unmounted.")
}

</script>


</body>
</html>